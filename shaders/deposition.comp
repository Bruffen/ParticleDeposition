#version 430
// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
uint hash( uint x ) {
    x += ( x << 10u );
    x ^= ( x >>  6u );
    x += ( x <<  3u );
    x ^= ( x >> 11u );
    x += ( x << 15u );
    return x;
}

// Compound versions of the hashing algorithm I whipped together.
uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }

// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
float floatConstruct( uint m ) {
    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                          // Add fractional part to 1.0

    float  f = uintBitsToFloat( m );       // Range [1:2]
    return f - 1.0;                        // Range [0:1]
}

// Pseudo-random value in half-open range [0:1].
float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in; // optimize

uniform sampler2D heightMap;
//uniform restrict image2D texVolume;

layout(binding=0, rgba8) uniform image2D texVolumeAux;
uniform image2D writeonly texVolume;
uniform int texWidth;
uniform int texHeight;

// Params from the camera that renders the scene from above
uniform float sceneHt; // max y bound
uniform float sceneRt; // max x bound
uniform float sceneLf; // min x bound
uniform float sceneUp; // max z bound
uniform float sceneDw; // min z bound

//Particle "stats"
uniform float radius;
uniform float gravity;
uniform float speed;
uniform vec3 windDir;
uniform float minHeight;
uniform float transferRate;

uniform float time;


// Simplex 2D noise
//
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  const vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

float checkSend(uint i,uint j,int ipp,int jpp,float curr){
    vec4 neighboor = imageLoad(texVolumeAux, ivec2(i +ipp, j+jpp ));
    float height = curr;
    if(neighboor.x > curr && (neighboor.x-curr) > minHeight ){
            
            height = curr+(neighboor.x-curr)*(transferRate);
            
    }else
    if(neighboor.x < curr && (curr-neighboor.x) > minHeight){

            height = curr-(curr-neighboor.x)*(transferRate);

    }
    return height;
}

void main()
{
    uint i = gl_GlobalInvocationID.x;
	uint j = gl_GlobalInvocationID.y;
	uint k = gl_GlobalInvocationID.x + gl_WorkGroupSize.x * gl_GlobalInvocationID.y;

    const float width  = sceneLf - sceneRt;
	const float height = sceneDw - sceneUp;
	const float center_x = width/2;
	const float center_z = height/2;
    int auxtime = int(time);
    barrier();
    if (auxtime<1000){

        if((i==j) || ((i-j)%10 == 0) || (((1024-i)-j)%10 == 0) )
            imageStore(texVolume, ivec2(i, j ), vec4(1.0));
            else 
            imageStore(texVolume, ivec2(i, j ), vec4(0));
        return;
    }
    
    
    
    if(auxtime%10 == 0)
    {
        //TODO: Pick Directions properly as it's the major bug source
        vec4 curr  = imageLoad(texVolumeAux, ivec2(i, j ));
        float currval = curr.x;
        //left  
        currval = checkSend(i,j, 0,-1,currval);
        //right 
        currval = checkSend(i,j,-1, 0,currval);
        currval = checkSend(i,j, 0,+1,currval);
        //top   
        //bot   
        currval = checkSend(i,j,+1, 0,currval);
        
        imageStore(texVolume, ivec2(i, j ),
                vec4(currval)
            );
        
    }
}