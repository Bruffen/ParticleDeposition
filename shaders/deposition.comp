#version 430

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in; // optimize

uniform sampler2D heightMap;
//uniform restrict image2D texVolume;

layout(binding=2, rgba32f) uniform image2D  texVolume;

uniform sampler2D heightMap1;
uniform sampler2D heightMap2;
uniform sampler2D heightMap3;
uniform sampler2D heightMap4;
uniform sampler2D heightBot1;
uniform sampler2D heightBot2;
uniform sampler2D heightBot3;
uniform sampler2D heightBot4;

layout(binding=1, rgba32f) uniform image2D  texVolume1;
layout(binding=2, rgba32f) uniform image2D  texVolume2;
layout(binding=3, rgba32f) uniform image2D  texVolume3;
layout(binding=4, rgba32f) uniform image2D  texVolume4;

uniform int texWidth;
uniform int texHeight;

// Params from the camera that renders the scene from above
uniform float sceneHt; // max y bound
uniform float sceneRt; // max x bound
uniform float sceneLf; // min x bound
uniform float sceneUp; // max z bound
uniform float sceneDw; // min z bound

//Particle "stats"
uniform float radius;
uniform float gravity;
uniform float speed;
uniform vec3 windDir;
uniform float minHeight;
uniform float viscosity;
uniform int simulIterations;
uniform float time;

uniform float height1;
uniform float height2;
uniform float height3;
uniform float width1;
uniform float width2;
uniform float width3;
uniform float width4;


float sendRecieve(float totalheight,float particleheight, float neibtotal, float neibparticle, float maxHeight, float maxNeib){

    float heightdif = (neibtotal-totalheight);
    float maxRec = max(maxHeight-particleheight,0);
    float maxRecNeib = max(maxNeib - neibparticle,0); 
    float transfer = 0.25 * clamp( clamp(heightdif, -1*particleheight,neibparticle),
                                    -1*maxRecNeib, 
                                    maxRec);
    if(abs(heightdif*0.25) < minHeight)
        return 0;//0.1*(1-viscosity)*transfer; 
    return (1-viscosity)*transfer;

}

float getheight1(uint i,uint j){
    if(i < 0 || j < 0 || i == texWidth || j == texWidth)
        return 9999.0;
    return (vec4((1-texture(heightMap1, vec2(-1,1)*(vec2(i,j)/texWidth))))).x*width1+height1;
}

float getmax1(uint i, uint j){

    float topmap = texture(heightBot1, vec2(-1,-1)*(vec2(i,j)/texWidth)).x*width1+height1;
    float botmap = getheight1(i,j);
    return max(0,topmap-botmap);
}

float getheight2(uint i,uint j){
    if(i < 0 || j < 0 || i == texWidth || j == texWidth)
        return 9999.0;
    return (vec4((1-texture(heightMap2, vec2(-1,1)*vec2(-1,1)*(vec2(i,j)/texWidth))))).x*width2+height2 ;
}

float getmax2(uint i, uint j){

    float topmap = texture(heightBot2, vec2(-1,-1)*(vec2(i,j)/texWidth)).x*width2+height2;
    float botmap = getheight2(i,j);
    return max(0,topmap-botmap);
}

float getheight3(uint i,uint j){
    if(i < 0 || j < 0 || i == texWidth || j == texWidth)
        return 9999.0;
    return (vec4((1-texture(heightMap3, vec2(-1,1)*(vec2(i,j)/texWidth))))).x*width3+height3 ;
}

float getmax3(uint i, uint j){

    float topmap = texture(heightBot3, vec2(-1,-1)*(vec2(i,j)/texWidth)).x*width3+height3;
    float botmap = getheight3(i,j);
    return max(0,topmap-botmap);
}


float getheight4(uint i,uint j){
    if(i < 0 || j < 0 || i == texWidth || j == texWidth)
        return 9999.0;
    return (vec4((1-texture(heightMap4, vec2(-1,1)*(vec2(i,j)/texWidth))))).x*width4 ;
}

float getmax4(uint i, uint j){

    float topmap = texture(heightBot4, vec2(-1,-1)*(vec2(i,j)/texWidth)).x*width4;
    float botmap = getheight4(i,j);
    return max(0,topmap-botmap);
}



void main(){
    uint i = gl_GlobalInvocationID.x;
	uint j = gl_GlobalInvocationID.y;
	uint k = gl_GlobalInvocationID.x + gl_WorkGroupSize.x * gl_GlobalInvocationID.y;

    const float width  = sceneLf - sceneRt;
	const float height = sceneDw - sceneUp;
	const float center_x = width/2;
	const float center_z = height/2;
    int auxtime = int(time);
    {

        for(int iter=0; iter < simulIterations;iter ++)
        {
            groupMemoryBarrier();
    
            float curr  = imageLoad(texVolume1,ivec2(i,j)).x;
            float top   = imageLoad(texVolume1,ivec2(i-1,j)).x;
            float bot   = imageLoad(texVolume1,ivec2(i+1,j)).x;
            float right = imageLoad(texVolume1,ivec2(i,j+1)).x;
            float left  = imageLoad(texVolume1,ivec2(i,j-1)).x;
            float totalcurr  = curr  + getheight1(i,j);
            float totaltop   = top   + getheight1(i-1,j);
            float totalbot   = bot   + getheight1(i+1,j);
            float totalright = right + getheight1(i,j+1);
            float totalleft  = left  + getheight1(i,j-1);
    
            float maxcurr    = getmax1(i,j);
            float maxtop     = getmax1(i-1,j);
            float maxbot     = getmax1(i+1,j);
            float maxright   = getmax1(i,j+1);
            float maxleft    = getmax1(i,j-1);
    
    
            float aux = curr;
            aux += sendRecieve(totalcurr,curr,totaltop,top,maxcurr,maxtop);    
            aux += sendRecieve(totalcurr,curr,totalbot,bot,maxcurr,maxbot);
            aux += sendRecieve(totalcurr,curr,totalright,right,maxcurr,maxright);
            aux += sendRecieve(totalcurr,curr,totalleft,left,maxcurr,maxleft);
    
            groupMemoryBarrier();
            imageStore(texVolume1, ivec2(i, j ),
                    vec4( clamp(0, 0,maxcurr)
                       ,getheight1(i,j),0,0)
                );
        }
        
    }

    {

        for(int iter=0; iter < simulIterations;iter ++)
        {
            groupMemoryBarrier();
    
            float curr  = imageLoad(texVolume2,ivec2(i,j)).x;
            float top   = imageLoad(texVolume2,ivec2(i-1,j)).x;
            float bot   = imageLoad(texVolume2,ivec2(i+1,j)).x;
            float right = imageLoad(texVolume2,ivec2(i,j+1)).x;
            float left  = imageLoad(texVolume2,ivec2(i,j-1)).x;
            float totalcurr  = curr  + getheight2(i,j);
            float totaltop   = top   + getheight2(i-1,j);
            float totalbot   = bot   + getheight2(i+1,j);
            float totalright = right + getheight2(i,j+1);
            float totalleft  = left  + getheight2(i,j-1);
    
            float maxcurr    = getmax2(i,j);
            float maxtop     = getmax2(i-1,j);
            float maxbot     = getmax2(i+1,j);
            float maxright   = getmax2(i,j+1);
            float maxleft    = getmax2(i,j-1);
    
    
            float aux = curr;
            aux += sendRecieve(totalcurr,curr,totaltop,top,maxcurr,maxtop);    
            aux += sendRecieve(totalcurr,curr,totalbot,bot,maxcurr,maxbot);
            aux += sendRecieve(totalcurr,curr,totalright,right,maxcurr,maxright);
            aux += sendRecieve(totalcurr,curr,totalleft,left,maxcurr,maxleft);
    
            groupMemoryBarrier();
            imageStore(texVolume2, ivec2(i, j ),
                    vec4( clamp(0, 0,maxcurr)
                       ,getheight2(i,j),0,0)
                );
        }
        
    }

    {

        for(int iter=0; iter < simulIterations;iter ++)
        {
            groupMemoryBarrier();
    
            float curr  = imageLoad(texVolume3,ivec2(i,j)).x;
            float top   = imageLoad(texVolume3,ivec2(i-1,j)).x;
            float bot   = imageLoad(texVolume3,ivec2(i+1,j)).x;
            float right = imageLoad(texVolume3,ivec2(i,j+1)).x;
            float left  = imageLoad(texVolume3,ivec2(i,j-1)).x;
            float totalcurr  = curr  + getheight3(i,j);
            float totaltop   = top   + getheight3(i-1,j);
            float totalbot   = bot   + getheight3(i+1,j);
            float totalright = right + getheight3(i,j+1);
            float totalleft  = left  + getheight3(i,j-1);
    
            float maxcurr    = getmax3(i,j);
            float maxtop     = getmax3(i-1,j);
            float maxbot     = getmax3(i+1,j);
            float maxright   = getmax3(i,j+1);
            float maxleft    = getmax3(i,j-1);
    
    
            float aux = curr;
            aux += sendRecieve(totalcurr,curr,totaltop,top,maxcurr,maxtop);    
            aux += sendRecieve(totalcurr,curr,totalbot,bot,maxcurr,maxbot);
            aux += sendRecieve(totalcurr,curr,totalright,right,maxcurr,maxright);
            aux += sendRecieve(totalcurr,curr,totalleft,left,maxcurr,maxleft);
    
            groupMemoryBarrier();
            imageStore(texVolume3, ivec2(i, j ),
                    vec4( clamp(0.2, 0.0,maxcurr)
                       ,getheight3(i,j),0,0)
                );
        }
        
    }

    {

        for(int iter=0; iter < simulIterations;iter ++)
        {
            groupMemoryBarrier();
    
            float curr  = imageLoad(texVolume4,ivec2(i,j)).x;
            float top   = imageLoad(texVolume4,ivec2(i-1,j)).x;
            float bot   = imageLoad(texVolume4,ivec2(i+1,j)).x;
            float right = imageLoad(texVolume4,ivec2(i,j+1)).x;
            float left  = imageLoad(texVolume4,ivec2(i,j-1)).x;
            float totalcurr  = curr  + getheight4(i,j);
            float totaltop   = top   + getheight4(i-1,j);
            float totalbot   = bot   + getheight4(i+1,j);
            float totalright = right + getheight4(i,j+1);
            float totalleft  = left  + getheight4(i,j-1);
    
            float maxcurr    = getmax4(i,j);
            float maxtop     = getmax4(i-1,j);
            float maxbot     = getmax4(i+1,j);
            float maxright   = getmax4(i,j+1);
            float maxleft    = getmax4(i,j-1);
    
    
            float aux = curr;
            aux += sendRecieve(totalcurr,curr,totaltop,top,maxcurr,maxtop);    
            aux += sendRecieve(totalcurr,curr,totalbot,bot,maxcurr,maxbot);
            aux += sendRecieve(totalcurr,curr,totalright,right,maxcurr,maxright);
            aux += sendRecieve(totalcurr,curr,totalleft,left,maxcurr,maxleft);
    
            groupMemoryBarrier();
            imageStore(texVolume4, ivec2(i, j ),
                    vec4( clamp(1, 0,maxcurr)
                       ,getheight4(i,j),0,0)
                );
        }
        
    }
}

