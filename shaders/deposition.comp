#version 430
// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
uint hash( uint x ) {
    x += ( x << 10u );
    x ^= ( x >>  6u );
    x += ( x <<  3u );
    x ^= ( x >> 11u );
    x += ( x << 15u );
    return x;
}

// Compound versions of the hashing algorithm I whipped together.
uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }

// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
float floatConstruct( uint m ) {
    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                          // Add fractional part to 1.0

    float  f = uintBitsToFloat( m );       // Range [1:2]
    return f - 1.0;                        // Range [0:1]
}

// Pseudo-random value in half-open range [0:1].
float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}


// Simplex 2D noise
//
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  const vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in; // optimize

uniform sampler2D heightMap;
//uniform restrict image2D texVolume;

layout(binding=0, rgba32f) uniform image2D texVolumeAux;
layout(binding=2, rgba32f) uniform image2D  texVolume;
uniform int texWidth;
uniform int texHeight;

// Params from the camera that renders the scene from above
uniform float sceneHt; // max y bound
uniform float sceneRt; // max x bound
uniform float sceneLf; // min x bound
uniform float sceneUp; // max z bound
uniform float sceneDw; // min z bound

//Particle "stats"
uniform float radius;
uniform float gravity;
uniform float speed;
uniform vec3 windDir;
uniform float minHeight;
uniform float viscosity;
uniform int simulIterations;
uniform float time;






float checkSend(uint i,uint j,int ipp,int jpp,float curr){
    vec4 neighboor = imageLoad(texVolumeAux, ivec2(i +ipp, j+jpp ));
    float height = curr;
    if(neighboor.x > curr && (neighboor.x-curr) > minHeight ){
            
            height = curr+(neighboor.x-curr)*(viscosity);
            
    }else
    if(neighboor.x < curr && (curr-neighboor.x) > minHeight){

            height = curr-(curr-neighboor.x)*(viscosity);

    }
    return height;
}


float sendRecieve(float totalheight,float particleheight, float neibtotal, float neibparticle){

    float heightdif = (neibtotal-totalheight);
    float transfer = 0.25*min(max(heightdif,-1*particleheight),neibparticle);//clamp(heightdif, -1*particleheight,neibparticle);
    if(abs(heightdif*0.25) < minHeight)
        return 0;//0.1*(1-viscosity)*transfer; 
    return (1-viscosity)*transfer;

}

float gettex(uint i,uint j){
    return (vec4((1-texture(heightMap, vec2(-1,1)*(vec2(i,j)/texWidth))))*sceneHt).x ;
}

void swapBuffers(){
    uint i = gl_GlobalInvocationID.x;
	uint j = gl_GlobalInvocationID.y;

    vec4 aux = imageLoad(texVolume, ivec2(i, j ));
    imageStore(texVolume, ivec2(i, j),imageLoad(texVolumeAux, ivec2(i,j)));
    imageStore(texVolumeAux, ivec2(i, j),aux);
    groupMemoryBarrier();
}

void main(){

    uint i = gl_GlobalInvocationID.x;
	uint j = gl_GlobalInvocationID.y;
	uint k = gl_GlobalInvocationID.x + gl_WorkGroupSize.x * gl_GlobalInvocationID.y;

    const float width  = sceneLf - sceneRt;
	const float height = sceneDw - sceneUp;
	const float center_x = width/2;
	const float center_z = height/2;
    int auxtime = int(time);
    for(int iter=0; iter < simulIterations;iter ++)
    {
        swapBuffers();
        float curr  = imageLoad(texVolumeAux,ivec2(i,j)).x;
        float top   = imageLoad(texVolumeAux,ivec2(i-1,j)).x;
        float bot   = imageLoad(texVolumeAux,ivec2(i+1,j)).x;
        float right = imageLoad(texVolumeAux,ivec2(i,j+1)).x;
        float left  = imageLoad(texVolumeAux,ivec2(i,j-1)).x;
        float totalcurr  = curr  + gettex(i,j);
        float totaltop   = top   + gettex(i-1,j);
        float totalbot   = bot   + gettex(i+1,j);
        float totalright = right + gettex(i,j+1);
        float totalleft  = left  + gettex(i,j-1);

        float aux = curr;
        aux += sendRecieve(totalcurr,curr,totaltop,top);    
        aux += sendRecieve(totalcurr,curr,totalbot,bot);
        aux += sendRecieve(totalcurr,curr,totalright,right);
        aux += sendRecieve(totalcurr,curr,totalleft,left);

        imageStore(texVolume, ivec2(i, j ),
                vec4(aux)
                //vec4(curr*viscosity + (1-viscosity)*0.25*(top+bot+right+left))
            );
    }

    //imageStore(texVolume, ivec2(i, j ), vec4(gettex(i,j)) );
}

//void main()
//{
//    uint i = gl_GlobalInvocationID.x;
//	uint j = gl_GlobalInvocationID.y;
//	uint k = gl_GlobalInvocationID.x + gl_WorkGroupSize.x * gl_GlobalInvocationID.y;
//
//    const float width  = sceneLf - sceneRt;
//	const float height = sceneDw - sceneUp;
//	const float center_x = width/2;
//	const float center_z = height/2;
//    int auxtime = int(time);
//    
//    barrier();
//
//  //  if (auxtime<1000)
////
//    //imageStore(texVolume, ivec2(i, j ), texture(heightMap,ivec2(i,j))+vec4(1.0));
//    //    if((i==j) || ((i-j)%10 == 0) || (((1024-i)-j)%10 == 0) )
//    //        imageStore(texVolume, ivec2(i, j ), vec4(1.0));
//    //        else 
//    //        imageStore(texVolume, ivec2(i, j ), vec4(0));
//    //    return;
//    //}
//
//    float viscosidade = minHeight;
//    
//    //Delta time
//
//    float dt = 1;
//    
//    float a = viscosidade * dt / ((width-2) * (height-2));
//    float c = 1 +4*a;
//    //if(i!=0 && j !=0 && i < width && j < height){
//
//        vec4 curr = imageLoad(texVolumeAux, ivec2(i, j ));
//
//        vec4 aux =  imageLoad(texVolume, ivec2(i+1, j))+
//                    imageLoad(texVolume, ivec2(i-1, j))+
//                    imageLoad(texVolume, ivec2(i, j+1))+
//                    imageLoad(texVolume, ivec2(i, j-1));
//
//        //aux = aux/4;
//        curr = (curr+a*aux)/c;
//        imageStore(texVolume, ivec2(i, j ),
//                    vec4(curr)
//                );
//        
//    //}    
//
//}